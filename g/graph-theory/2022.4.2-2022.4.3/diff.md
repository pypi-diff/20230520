# Comparing `tmp/graph_theory-2022.4.2-py3-none-any.whl.zip` & `tmp/graph_theory-2022.4.3-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,19 +1,19 @@
-Zip file size: 49896 bytes, number of entries: 17
--rw-r--r--  2.0 unx    88664 b- defN 22-Dec-12 09:05 graph/__init__.py
--rw-r--r--  2.0 unx     8270 b- defN 22-Dec-12 09:05 graph/assignment_problem.py
--rw-r--r--  2.0 unx     2178 b- defN 22-Dec-12 09:05 graph/finite_state_machine.py
--rw-r--r--  2.0 unx     4436 b- defN 22-Dec-12 09:05 graph/hash.py
--rw-r--r--  2.0 unx     2580 b- defN 22-Dec-12 09:05 graph/random.py
--rw-r--r--  2.0 unx    21255 b- defN 22-Dec-12 09:05 graph/traffic_scheduling_problem.py
--rw-r--r--  2.0 unx     9086 b- defN 22-Dec-12 09:05 graph/transshipment_problem.py
--rw-r--r--  2.0 unx      131 b- defN 22-Dec-12 09:05 graph/version.py
--rw-r--r--  2.0 unx     5304 b- defN 22-Dec-12 09:05 graph/visuals.py
--rw-r--r--  2.0 unx     1064 b- defN 22-Dec-12 09:05 graph_theory-2022.4.2.data/data/LICENSE
--rw-r--r--  2.0 unx    22308 b- defN 22-Dec-12 09:05 graph_theory-2022.4.2.data/data/README.md
--rw-r--r--  2.0 unx       17 b- defN 22-Dec-12 09:05 graph_theory-2022.4.2.data/data/requirements.txt
--rw-r--r--  2.0 unx     1064 b- defN 22-Dec-12 09:05 graph_theory-2022.4.2.dist-info/LICENSE
--rw-r--r--  2.0 unx    23830 b- defN 22-Dec-12 09:05 graph_theory-2022.4.2.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 22-Dec-12 09:05 graph_theory-2022.4.2.dist-info/WHEEL
--rw-r--r--  2.0 unx        6 b- defN 22-Dec-12 09:05 graph_theory-2022.4.2.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     1436 b- defN 22-Dec-12 09:05 graph_theory-2022.4.2.dist-info/RECORD
-17 files, 191721 bytes uncompressed, 47532 bytes compressed:  75.2%
+Zip file size: 50734 bytes, number of entries: 17
+-rw-r--r--  2.0 unx    90165 b- defN 23-May-20 15:04 graph/__init__.py
+-rw-r--r--  2.0 unx     8270 b- defN 23-May-20 15:04 graph/assignment_problem.py
+-rw-r--r--  2.0 unx     2178 b- defN 23-May-20 15:04 graph/finite_state_machine.py
+-rw-r--r--  2.0 unx     4436 b- defN 23-May-20 15:04 graph/hash.py
+-rw-r--r--  2.0 unx     2580 b- defN 23-May-20 15:04 graph/random.py
+-rw-r--r--  2.0 unx    21255 b- defN 23-May-20 15:04 graph/traffic_scheduling_problem.py
+-rw-r--r--  2.0 unx     9086 b- defN 23-May-20 15:04 graph/transshipment_problem.py
+-rw-r--r--  2.0 unx      131 b- defN 23-May-20 15:04 graph/version.py
+-rw-r--r--  2.0 unx     5304 b- defN 23-May-20 15:04 graph/visuals.py
+-rw-r--r--  2.0 unx     1064 b- defN 23-May-20 15:04 graph_theory-2022.4.3.data/data/LICENSE
+-rw-r--r--  2.0 unx    22547 b- defN 23-May-20 15:04 graph_theory-2022.4.3.data/data/README.md
+-rw-r--r--  2.0 unx       17 b- defN 23-May-20 15:04 graph_theory-2022.4.3.data/data/requirements.txt
+-rw-r--r--  2.0 unx     1064 b- defN 23-May-20 15:04 graph_theory-2022.4.3.dist-info/LICENSE
+-rw-r--r--  2.0 unx    24069 b- defN 23-May-20 15:04 graph_theory-2022.4.3.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-May-20 15:04 graph_theory-2022.4.3.dist-info/WHEEL
+-rw-r--r--  2.0 unx        6 b- defN 23-May-20 15:04 graph_theory-2022.4.3.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     1436 b- defN 23-May-20 15:04 graph_theory-2022.4.3.dist-info/RECORD
+17 files, 193700 bytes uncompressed, 48370 bytes compressed:  75.0%
```

## zipnote {}

```diff
@@ -21,32 +21,32 @@
 
 Filename: graph/version.py
 Comment: 
 
 Filename: graph/visuals.py
 Comment: 
 
-Filename: graph_theory-2022.4.2.data/data/LICENSE
+Filename: graph_theory-2022.4.3.data/data/LICENSE
 Comment: 
 
-Filename: graph_theory-2022.4.2.data/data/README.md
+Filename: graph_theory-2022.4.3.data/data/README.md
 Comment: 
 
-Filename: graph_theory-2022.4.2.data/data/requirements.txt
+Filename: graph_theory-2022.4.3.data/data/requirements.txt
 Comment: 
 
-Filename: graph_theory-2022.4.2.dist-info/LICENSE
+Filename: graph_theory-2022.4.3.dist-info/LICENSE
 Comment: 
 
-Filename: graph_theory-2022.4.2.dist-info/METADATA
+Filename: graph_theory-2022.4.3.dist-info/METADATA
 Comment: 
 
-Filename: graph_theory-2022.4.2.dist-info/WHEEL
+Filename: graph_theory-2022.4.3.dist-info/WHEEL
 Comment: 
 
-Filename: graph_theory-2022.4.2.dist-info/top_level.txt
+Filename: graph_theory-2022.4.3.dist-info/top_level.txt
 Comment: 
 
-Filename: graph_theory-2022.4.2.dist-info/RECORD
+Filename: graph_theory-2022.4.3.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## graph/__init__.py

```diff
@@ -746,15 +746,14 @@
         unassigned_flow -= path_flow
         total_flow += path_flow
 
         # 3. record the flows and update the inverted graph, so that it is
         #    ready for the next iteration.
         edges = graph.edges(path)
         for n1, n2, d in edges:
-
             # 3.a. recording:
             v = flow_graph.edge(n1, n2, default=None)
             if v is None:
                 flow_graph.add_edge(n1, n2, path_flow)
                 c = graph.edge(n1, n2) - path_flow
             else:
                 flow_graph.add_edge(n1, n2, value=v + path_flow)
@@ -907,15 +906,14 @@
         raise TypeError(f"Expected BasicGraph, Graph or Graph3D, not {type(graph)}")
 
     def lower_bound(graph, nodes):
         """Calculates the lower bound of distances for given nodes."""
         L = []
         edges = set()
         for n in nodes:
-
             L2 = [(d, e) for s, e, d in graph.edges(from_node=n) if e in nodes - {n}]
             if not L2:
                 continue
             L2.sort()
 
             for d, n2 in L2:
                 if (n2, n) in edges:  # Solution is not valid as it creates a loop.
@@ -960,15 +958,14 @@
                 d, tour = q2.pop(0)
                 assert d >= global_lower_bound, "Solution not possible."
                 return d, list(tour[:-1])
 
         remaining_nodes = all_nodes - tour_set
 
         for n2 in remaining_nodes:
-
             new_tour = tour + (n2,)
 
             lb_set = remaining_nodes - {n2}
             if len(lb_set) > 1:
                 lb_dists = lower_bound(graph, lb_set)
                 lb = sum(d for n, n2, d in lb_dists)
                 new_lb = graph.distance_from_path(new_tour) + lb
@@ -1170,21 +1167,22 @@
     """Checks if graph has a cycle
     :param graph: instance of class Graph.
     :return: bool
     """
     if not isinstance(graph, (BasicGraph, Graph, Graph3D)):
         raise TypeError(f"Expected BasicGraph, Graph or Graph3D, not {type(graph)}")
 
-    for n1, n2, d in graph.edges():
-        if n1 == n2:
+    for n1, n2, _ in graph.edges():
+        if n1 == n2:  # detect nodes that point to themselves
             return True
-        if graph.is_connected(n2, n1):
-            return True
-    return False
-
+    try:
+        _ = list(graph.phase_lines())  # tries to create a DAG.
+        return False
+    except AttributeError:
+        return True
 
 def components(graph):
     """Determines the components of the graph
     :param graph: instance of class Graph
     :return: list of sets of nodes. Each set is a component.
     """
     if not isinstance(graph, (BasicGraph, Graph, Graph3D)):
@@ -1258,15 +1256,15 @@
     :param key: optional function for sortation.
     :return: Generator
 
     Topological sort (ordering) is a linear ordering of vertices.
     https://en.wikipedia.org/wiki/Topological_sorting
 
     Note: The algorithm does not check for loops before initiating
-    the sortation, but raise Exception at the first conflict.
+    the sortation, but raise AttributeError at the first conflict.
     This saves O(m+n) runtime.
 
     """
     if not isinstance(graph, (BasicGraph, Graph, Graph3D)):
         raise TypeError(f"Expected BasicGraph, Graph or Graph3D, not {type(graph)}")
 
     if key is None:
@@ -1283,19 +1281,62 @@
             yield task  # <--- do something.
 
             g2.del_node(task)
 
         zero_in_degree = sorted(g2.nodes(in_degree=0), key=key)
 
     if g2.nodes():
-        raise TypeError(f"Graph is not acyclic: Loop found: {g2.nodes()}")
+        raise AttributeError(f"Graph is not acyclic: Loop found: {g2.nodes()}")
 
 
 def phase_lines(graph):
     """Determines the phase lines of a directed graph.
+
+    This is useful for determining which tasks can be performed in 
+    parallel. Each phase in the phaselines must be completed to assure
+    that the tasks in the next phase can be performed with complete input.
+
+    This is in contrast to Topological sort that only generates
+    a queue of tasks, may be fine for a single processor, but has no 
+    mechanism for coordination that all inputs for a task have been completed
+    so that multiple processors can work on them.
+
+    Example: DAG with tasks:
+    
+        u1      u4      u2      u3
+        \       \       \_______\
+        csg     cs3       append
+        \       \           \
+        op1     \           op3
+        \       \           \
+        op2     \           cs2
+        \       \___________\
+        cs1         join
+        \           \
+        map1        map2
+        \___________\
+            save
+
+    phaselines = {
+        "u1": 0, "u4": 0, "u2": 0, "u3": 0, 
+        "csg": 1, "cs3": 1, "append": 1,
+        "op1": 2, "op3": 2, "op2": 3, "cs2": 3,
+        "cs1": 4, "join": 4,
+        "map1": 5, "map2": 5,
+        "save": 6,
+    }  
+
+    From this example it is visible that processing the 4 'uN' (uploads) is
+    the highest degree of concurrency. This can be determined as follows:
+
+        d = defaultdict(int)
+        for _, pl in graph.phaselines():
+            d[pl] += 1
+        max_processors = max(d, key=d.get)
+
     :param graph: Graph
     :return: dictionary with node id : phase in cut.
 
     Note: To transform the phaselines into a task sequence use
     the following recipe:
 
     tasks = defaultdict(set)
@@ -1307,48 +1348,47 @@
     for phase in sorted(tasks):
         print(phase, list(sorted(tasks[phase]))
 
     """
     if not isinstance(graph, (BasicGraph, Graph, Graph3D)):
         raise TypeError(f"Expected BasicGraph, Graph or Graph3D, not {type(graph)}")
 
-    phases = {n: 0 for n in graph.nodes()}
-    sinks = {n: set() for n in phases}  # sinks[e] = {s1,s2}
-    edges = {n: set() for n in phases}
-    for s, e, d in graph.edges():
-        sinks[e].add(s)
-        edges[s].add(e)
-
-    cache = {}
-
-    level = 0
-    while sinks:
-        sources = [e for e in sinks if not sinks[e]]  # these nodes have in_degree=0
-        if not sources:
-            raise AttributeError("The graph does not have any sinks.")
-        for s in sources:
-            phases[s] = level  # let's update the phase value
-            del sinks[s]  # and let's remove their sink entry.
-            # and remove their set item from the sinks dict
-            for e in edges[s]:
-                if e not in sinks:
-                    continue
-                sinks[e].discard(s)
-                # but also check if their descendants are loops.
-                for s2 in list(sinks[e]):
-
-                    con = cache.get((e, s2))  # check if the edge has been seen before.
-                    if con is None:
-                        con = graph.is_connected(e, s2)  # if not seen before, search...
-                        cache[(e, s2)] = con
-
-                    if con:
-                        sinks[e].discard(s2)
-        level += 1
+    nmax = len(graph.nodes())
+    phases = {n: nmax + 1 for n in graph.nodes()}
+    phase_counter = 0
+    
+    g2 = graph.copy()
+    q = list(g2.nodes(in_degree=0))  # Current iterations work queue
+    if not q:
+        raise AttributeError("The graph does not have any sources.")
 
+    q2 = set()  # Next iterations work queue
+    while q:
+        for n1 in q:
+            if g2.in_degree(n1)!=0:  
+                q2.add(n1)  # n1 has an in coming edge, so it has to wait.
+                continue
+            phases[n1] = phase_counter  # update the phaseline number
+            for n2 in g2.nodes(from_node=n1):
+                q2.add(n2)  # add node for next iteration
+
+        # at this point the nodes with no incoming edges have been accounted
+        # for, so now they may be removed for the working graph.
+        for n1 in q:
+            if n1 not in q2:
+                g2.del_node(n1)  # remove nodes that have no incoming edges
+
+        if set(q) == q2:
+            raise AttributeError(f"Loop found: The graph is not acyclic!")
+        
+        # Finally turn the next iterations workqueue into current.
+        # and increment the phaseline counter.
+        q = [n for n in q2]
+        q2.clear()
+        phase_counter += 1
     return phases
 
 
 def sources(graph, n):
     """Determines the set of all upstream sources of node 'n' in a DAG.
     :param graph: Graph
     :param n: node for which the sources are sought.
@@ -2500,15 +2540,14 @@
             n2
             for n2 in slack_node_ids
             if n2 != n1  # ...not on critical path
             and phases[n2] >= phases[n1]  # ...not pointing to the source
             and new_graph.edge(n2, n1) is None  # ...downstream
             and new_graph.edge(n1, n2) is None  # ... not creating a cycle.
         ):  # ... not already a dependency.
-
             new_graph.add_edge(n1, n2)
             new_edges.append((n1, n2))
 
             cpl2, schedule2 = critical_path(new_graph)
             if cpl2 != cpl:  # the critical path is not allowed to be longer. Abort.
                 new_graph.del_edge(n1, n2)
                 new_edges.remove((n1, n2))
```

## graph/version.py

```diff
@@ -1,3 +1,3 @@
-major, minor, patch = 2022, 4, 2
+major, minor, patch = 2022, 4, 3
 __version_info__ = (major, minor, patch)
 __version__ = ".".join(str(i) for i in __version_info__)
```

## Comparing `graph_theory-2022.4.2.data/data/LICENSE` & `graph_theory-2022.4.3.data/data/LICENSE`

 * *Files identical despite different names*

## Comparing `graph_theory-2022.4.2.data/data/README.md` & `graph_theory-2022.4.3.data/data/README.md`

 * *Files 2% similar despite different names*

```diff
@@ -14,14 +14,15 @@
 Detailed tutorial evolving in the [examples section](https://github.com/root-11/graph-theory/blob/master/examples/readme.md).
 ---------------------------
 
 Latest features:
 
 | date | description |
 |---|---|
+| 2023/05/20 | Maintenance release (2022.4.3) [graph.phaseline](https://github.com/root-11/graph-theory/blob/da8b60137a73d7b7c23a960cb544181ca1bc122a/graph/__init__.py#L1291) has a new simpler and faster algorithm ( O(N*E) --> O(N+E) ). |
 | 2022/12/12 | Maintenance release (2022.4.2): To speed up the package import plot3d has been moved to function call. |
 | 2022/10/04 | New tutorial: [Learn to solve traffic jams and sudoku's](https://github.com/root-11/graph-theory/blob/master/examples/graphs%20as%20finite%20state%20machines.ipynb) |
 | 2022/03/09 | bugfixes to TrafficJamSolver only. |
 | 2022/01/04 | new feature: Graph.distance_map, which allows the user to compute<br>the distance from a number of starts and ends as simulated annealing map. |
 | 2022/01/04 | new generation of the traffic jam solver.|
 | 2021/12/12 | shortest path now accepts keyword `avoids`, which allows the user<br>to declare nodes which cannot be a part of the path.<br>This feature has no impact on performance.|
```

## Comparing `graph_theory-2022.4.2.dist-info/LICENSE` & `graph_theory-2022.4.3.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `graph_theory-2022.4.2.dist-info/METADATA` & `graph_theory-2022.4.3.dist-info/METADATA`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: graph-theory
-Version: 2022.4.2
+Version: 2022.4.3
 Summary: A graph library
 Home-page: https://github.com/root-11/graph-theory
 Author: https://github.com/root-11
 License: MIT
 Keywords: adjacency,adjacent,algorithms,all pairs shortest path,analysis,assignment problem,complex-networks,component,components,congestions,critical,critical-path,cycle,discrete mathematics,finite,finite state machine,flow,flow-problem,fsm,generate,generation,graph,Graph Theory,graph-algorithms,graph-analysis,graph-generation,graph-hash,graph-theory,graph-visualization,graphs,hash,hash-tree,hill-climbing,jam,machine,math,Mathematics,maths,matrix,merkle,merkle-tree,method,minimise,minimize,minimum,minimum-spanning-trees,network,Networks,optimisation,optimise,optimization,optimize,pairs,path,python,random graph,search,shortest,shortest-path,simple,simple-path,solver,spanning,state,theory,traffic,traffic-jam,traffic-jam-solver,tree,tsp,tsp-solver
 Platform: any
 Classifier: Development Status :: 5 - Production/Stable
@@ -37,14 +37,15 @@
 Detailed tutorial evolving in the [examples section](https://github.com/root-11/graph-theory/blob/master/examples/readme.md).
 ---------------------------
 
 Latest features:
 
 | date | description |
 |---|---|
+| 2023/05/20 | Maintenance release (2022.4.3) [graph.phaseline](https://github.com/root-11/graph-theory/blob/da8b60137a73d7b7c23a960cb544181ca1bc122a/graph/__init__.py#L1291) has a new simpler and faster algorithm ( O(N*E) --> O(N+E) ). |
 | 2022/12/12 | Maintenance release (2022.4.2): To speed up the package import plot3d has been moved to function call. |
 | 2022/10/04 | New tutorial: [Learn to solve traffic jams and sudoku's](https://github.com/root-11/graph-theory/blob/master/examples/graphs%20as%20finite%20state%20machines.ipynb) |
 | 2022/03/09 | bugfixes to TrafficJamSolver only. |
 | 2022/01/04 | new feature: Graph.distance_map, which allows the user to compute<br>the distance from a number of starts and ends as simulated annealing map. |
 | 2022/01/04 | new generation of the traffic jam solver.|
 | 2021/12/12 | shortest path now accepts keyword `avoids`, which allows the user<br>to declare nodes which cannot be a part of the path.<br>This feature has no impact on performance.|
```

